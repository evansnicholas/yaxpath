/*
 * generated by Xtext
 */
package org.xtext.example.xpath.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.xpath.xPath.*
import org.eclipse.emf.ecore.EObject;
import org.xtext.example.xpath.constants.StepChoice

import java.lang.StringBuilder

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class XPathGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val sb = new StringBuilder() 
		for (e: resource.allContents.toIterable.filter(ValueExpr)){
			val compiled = 
			'''def xpath(elem: Elem): IndexedSeq[Any] = {
				  val documentElem = Elem(QName("documentNode"))
                  val totalElem = documentElem.withChildren(Vector(elem))
			      «e.compile»
			   }
			'''
			sb.append(compiled)
		}
		fsa.generateFile("generation.scala", sb)
	}
	
	def dispatch compile(ValueExpr ve) {
		'''«ve.value.compile»'''
	}
	
	def dispatch compile(RelSingle rs) {
		'''totalElem«rs.relPathExpr.step.compile(true, StepChoice.SINGLE)»
		«IF rs.relPathExpr.extraSteps != null»
		«FOR extra: rs.relPathExpr.extraSteps»
		«extra.compile»
		«ENDFOR»
		«ENDIF»
		'''
	}
	
	def dispatch compile(RelDouble rd) {
		'''totalElem«rd.relPathExpr.step.compile(true, StepChoice.DOUBLE)»
		«IF rd.relPathExpr.extraSteps != null»
		«FOR extra: rd.relPathExpr.extraSteps»
		«extra.compile»
		«ENDFOR»
		«ENDIF»
		'''
	}
	
	def dispatch compile(Single s) {
		'''«compile(s.step, false, StepChoice.SINGLE)»'''
	}
	
	def dispatch compile(Double d) {
		'''«compile(d.step, false, StepChoice.DOUBLE)»'''
	}
	
	def dispatch compile(StepExpr se, Boolean isFirstStep, StepChoice stepChoice) {
		'''«se.stepExpr.compile(isFirstStep, stepChoice)»'''
	}
	
	def dispatch compile(AxisStep axs, Boolean isFirstStep, StepChoice stepChoice) {
		'''«compile(axs.step, isFirstStep, stepChoice)»«compile(axs.predicateList)»'''
	}
	
	def dispatch compile(ForwardStep fs, Boolean isFirstStep, StepChoice stepChoice) {
		'''«IF fs.forward != null»«fs.forward»«fs.test.compile»«ENDIF»«IF fs.abbrForward != null»«compile(fs.abbrForward, isFirstStep, stepChoice)»«ENDIF»'''
	}
	
	def dispatch compile(Element e, Boolean isFirstStep, StepChoice stepChoice) {
		switch isFirstStep {
			Boolean case isFirstStep == true: switch stepChoice {
				  case StepChoice.SINGLE: '''.filterChildElems { «e.test.compile» }'''
			      case StepChoice.DOUBLE: '''.filterElemsOrSelf { «e.test.compile» }'''
			    }
			Boolean case isFirstStep == false: switch stepChoice {
				  case StepChoice.SINGLE: '''.flatMap {  _.filterChildElems(«e.test.compile») }'''
			      case StepChoice.DOUBLE: '''.flatMap { _.filterElemsOrSelf(«e.test.compile») }'''
			    }    
		}
		
	}
	
	def dispatch compile(Attribute a, Boolean isFirstStep, StepChoice stepChoice){
		switch isFirstStep {
		   Boolean case isFirstStep == true: switch stepChoice {
			case StepChoice.SINGLE: '''.filterChildElems { elem => elem.attributeOption(«a.test.compile»).isDefined }
			                     .map { _.attribute(«a.test.compile») }'''
			case StepChoice.DOUBLE: '''.filterElemsOrSelf { elem => elem.attributeOption(«a.test.compile»).isDefined }
			                     .map { _.attribute(«a.test.compile») }'''
			}
		   Boolean case isFirstStep == false: switch stepChoice {
			case StepChoice.SINGLE: '''.collect {  case elem if elem.attributeOption(«a.test.compile»).isDefined =>  elem.attribute(«a.test.compile») }'''
			case StepChoice.DOUBLE: '''.flatMap { _.filterElemsOrSelf { elem => elem.attributeOption(«a.test.compile»).isDefined }
			                     .map { _.attribute(«a.test.compile») }'''
			}
		}
	}
	
	def dispatch compile(NodeTest not) {
		'''«not.test.compile»'''
	}
	
	def dispatch compile(NameTest nat) {
		'''«IF nat.QName != null»«nat.QName.compile»«ENDIF»«IF nat.wildcard != null»«nat.wildcard.compile»«ENDIF»'''
	}
	
	def dispatch compile(FilterExpr f) {
		'''«f.primary.compile»«f.predicateList.compile»'''
	}
	
	def dispatch compile(PrimaryExpr pe) {
		'''«IF pe.literal != null»«pe.literal.compile»«ENDIF»'''
	}
	
	def dispatch compile(Literal l) {
		'''«IF l.num != null»«l.num»«ENDIF»«IF l.string != null»«l.string»«ENDIF»'''
	}
	
	def dispatch compile(UnprefixedName un) {
		'''EName("«un.localPart.ncName»")'''
	}
	
	def dispatch compile(EObject o) {
	}
	
}
